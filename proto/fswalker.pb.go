// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/fswalker.proto

package fswalker

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Indicator for the severity of the notification.
type Notification_Severity int32

const (
	Notification_UNKNOWN Notification_Severity = 0
	Notification_INFO    Notification_Severity = 1
	Notification_WARNING Notification_Severity = 2
	Notification_ERROR   Notification_Severity = 3
)

var Notification_Severity_name = map[int32]string{
	0: "UNKNOWN",
	1: "INFO",
	2: "WARNING",
	3: "ERROR",
}

var Notification_Severity_value = map[string]int32{
	"UNKNOWN": 0,
	"INFO":    1,
	"WARNING": 2,
	"ERROR":   3,
}

func (x Notification_Severity) String() string {
	return proto.EnumName(Notification_Severity_name, int32(x))
}

func (Notification_Severity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{5, 0}
}

type Fingerprint_Method int32

const (
	Fingerprint_UNKNOWN Fingerprint_Method = 0
	Fingerprint_SHA256  Fingerprint_Method = 1
)

var Fingerprint_Method_name = map[int32]string{
	0: "UNKNOWN",
	1: "SHA256",
}

var Fingerprint_Method_value = map[string]int32{
	"UNKNOWN": 0,
	"SHA256":  1,
}

func (x Fingerprint_Method) String() string {
	return proto.EnumName(Fingerprint_Method_name, int32(x))
}

func (Fingerprint_Method) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{8, 0}
}

// Reviews is a collection of "known good" states, one per host.
// It is used to keep the default to compare newer reports against.
type Reviews struct {
	Review               map[string]*Review `protobuf:"bytes,1,rep,name=review,proto3" json:"review,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Reviews) Reset()         { *m = Reviews{} }
func (m *Reviews) String() string { return proto.CompactTextString(m) }
func (*Reviews) ProtoMessage()    {}
func (*Reviews) Descriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{0}
}

func (m *Reviews) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Reviews.Unmarshal(m, b)
}
func (m *Reviews) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Reviews.Marshal(b, m, deterministic)
}
func (m *Reviews) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reviews.Merge(m, src)
}
func (m *Reviews) XXX_Size() int {
	return xxx_messageInfo_Reviews.Size(m)
}
func (m *Reviews) XXX_DiscardUnknown() {
	xxx_messageInfo_Reviews.DiscardUnknown(m)
}

var xxx_messageInfo_Reviews proto.InternalMessageInfo

func (m *Reviews) GetReview() map[string]*Review {
	if m != nil {
		return m.Review
	}
	return nil
}

type Review struct {
	// The ID of the Walk that was reviewed and considered ok.
	// This will become the last known good.
	WalkId string `protobuf:"bytes,1,opt,name=walk_id,json=walkId,proto3" json:"walk_id,omitempty"`
	// Reference to the Walk source (e.g. absolute path).
	WalkReference string `protobuf:"bytes,2,opt,name=walk_reference,json=walkReference,proto3" json:"walk_reference,omitempty"`
	// Mandatory fingerprint of the walk file (to ensure integrity).
	Fingerprint          *Fingerprint `protobuf:"bytes,3,opt,name=fingerprint,proto3" json:"fingerprint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Review) Reset()         { *m = Review{} }
func (m *Review) String() string { return proto.CompactTextString(m) }
func (*Review) ProtoMessage()    {}
func (*Review) Descriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{1}
}

func (m *Review) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Review.Unmarshal(m, b)
}
func (m *Review) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Review.Marshal(b, m, deterministic)
}
func (m *Review) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Review.Merge(m, src)
}
func (m *Review) XXX_Size() int {
	return xxx_messageInfo_Review.Size(m)
}
func (m *Review) XXX_DiscardUnknown() {
	xxx_messageInfo_Review.DiscardUnknown(m)
}

var xxx_messageInfo_Review proto.InternalMessageInfo

func (m *Review) GetWalkId() string {
	if m != nil {
		return m.WalkId
	}
	return ""
}

func (m *Review) GetWalkReference() string {
	if m != nil {
		return m.WalkReference
	}
	return ""
}

func (m *Review) GetFingerprint() *Fingerprint {
	if m != nil {
		return m.Fingerprint
	}
	return nil
}

type ReportConfig struct {
	// version is the version of the proto structure.
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// exclude_pfx is a list of path prefixes which will be excluded from being
	// reported. Note that these are prefixes. Any path matching one of these
	// prefixes will be ignored. These are in addition to the exclusions in the
	// client policy so more things can be recorded (but ignored in the default
	// report).
	ExcludePfx           []string `protobuf:"bytes,2,rep,name=exclude_pfx,json=excludePfx,proto3" json:"exclude_pfx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportConfig) Reset()         { *m = ReportConfig{} }
func (m *ReportConfig) String() string { return proto.CompactTextString(m) }
func (*ReportConfig) ProtoMessage()    {}
func (*ReportConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{2}
}

func (m *ReportConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReportConfig.Unmarshal(m, b)
}
func (m *ReportConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReportConfig.Marshal(b, m, deterministic)
}
func (m *ReportConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportConfig.Merge(m, src)
}
func (m *ReportConfig) XXX_Size() int {
	return xxx_messageInfo_ReportConfig.Size(m)
}
func (m *ReportConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ReportConfig proto.InternalMessageInfo

func (m *ReportConfig) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ReportConfig) GetExcludePfx() []string {
	if m != nil {
		return m.ExcludePfx
	}
	return nil
}

type Policy struct {
	// version is the version of the proto structure.
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// include is a list of paths to use as roots for file walks.
	// Each walk can be done by a separate Go routine (if an idle one is
	// available). Important to note that the include paths SHOULD NOT contain
	// each other because that will lead to paths being visited more than once.
	Include []string `protobuf:"bytes,2,rep,name=include,proto3" json:"include,omitempty"`
	// exclude_pfx is a list of path prefixes which will be excluded from being
	// walked. Note that these are prefixes. Any path matching one of these
	// prefixes will be ignored.
	ExcludePfx []string `protobuf:"bytes,3,rep,name=exclude_pfx,json=excludePfx,proto3" json:"exclude_pfx,omitempty"`
	// hash_pfx is a list of path prefixes. If the discovered File path is not a
	// directory, matches one of the prefixes and is not larger than
	// max_hash_file_size, the file will be opened and a file hash built over its
	// content.
	HashPfx         []string `protobuf:"bytes,4,rep,name=hash_pfx,json=hashPfx,proto3" json:"hash_pfx,omitempty"`
	MaxHashFileSize int64    `protobuf:"varint,5,opt,name=max_hash_file_size,json=maxHashFileSize,proto3" json:"max_hash_file_size,omitempty"`
	// walk_cross_device controls whether files on different devices from the
	// include directories should be walked. I.e. if "/" is included, "/tmp" will
	// only be walked if it is not a separate mount point.
	WalkCrossDevice bool `protobuf:"varint,30,opt,name=walk_cross_device,json=walkCrossDevice,proto3" json:"walk_cross_device,omitempty"`
	// ignore_irregular_files controls whether irregular files (i.e. symlinks,
	// sockets, devices, etc) should be ignored.
	// Note that symlinks are NOT followed either way.
	IgnoreIrregularFiles bool `protobuf:"varint,31,opt,name=ignore_irregular_files,json=ignoreIrregularFiles,proto3" json:"ignore_irregular_files,omitempty"`
	// max_directory_depth controls how many levels of directories Walker should
	// walk into an included directory.
	// Defaults to no restriction on depth (i.e. go all the way).
	MaxDirectoryDepth    uint32   `protobuf:"varint,32,opt,name=max_directory_depth,json=maxDirectoryDepth,proto3" json:"max_directory_depth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Policy) Reset()         { *m = Policy{} }
func (m *Policy) String() string { return proto.CompactTextString(m) }
func (*Policy) ProtoMessage()    {}
func (*Policy) Descriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{3}
}

func (m *Policy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Policy.Unmarshal(m, b)
}
func (m *Policy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Policy.Marshal(b, m, deterministic)
}
func (m *Policy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Policy.Merge(m, src)
}
func (m *Policy) XXX_Size() int {
	return xxx_messageInfo_Policy.Size(m)
}
func (m *Policy) XXX_DiscardUnknown() {
	xxx_messageInfo_Policy.DiscardUnknown(m)
}

var xxx_messageInfo_Policy proto.InternalMessageInfo

func (m *Policy) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Policy) GetInclude() []string {
	if m != nil {
		return m.Include
	}
	return nil
}

func (m *Policy) GetExcludePfx() []string {
	if m != nil {
		return m.ExcludePfx
	}
	return nil
}

func (m *Policy) GetHashPfx() []string {
	if m != nil {
		return m.HashPfx
	}
	return nil
}

func (m *Policy) GetMaxHashFileSize() int64 {
	if m != nil {
		return m.MaxHashFileSize
	}
	return 0
}

func (m *Policy) GetWalkCrossDevice() bool {
	if m != nil {
		return m.WalkCrossDevice
	}
	return false
}

func (m *Policy) GetIgnoreIrregularFiles() bool {
	if m != nil {
		return m.IgnoreIrregularFiles
	}
	return false
}

func (m *Policy) GetMaxDirectoryDepth() uint32 {
	if m != nil {
		return m.MaxDirectoryDepth
	}
	return 0
}

type Walk struct {
	// A unique string identifying this specific Walk.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// version is the version of the proto structure.
	Version uint32 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// policy is the Policy that was used for the file walk.
	Policy *Policy `protobuf:"bytes,3,opt,name=policy,proto3" json:"policy,omitempty"`
	// file is a list of all files including metadata that were discovered.
	File []*File `protobuf:"bytes,4,rep,name=file,proto3" json:"file,omitempty"`
	// notification is a list of notifications that occurred during a walk.
	Notification []*Notification `protobuf:"bytes,5,rep,name=notification,proto3" json:"notification,omitempty"`
	// hostname of the machine the walk originates from.
	Hostname string `protobuf:"bytes,10,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// start and stop time of the walk.
	StartWalk            *timestamp.Timestamp `protobuf:"bytes,11,opt,name=start_walk,json=startWalk,proto3" json:"start_walk,omitempty"`
	StopWalk             *timestamp.Timestamp `protobuf:"bytes,12,opt,name=stop_walk,json=stopWalk,proto3" json:"stop_walk,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Walk) Reset()         { *m = Walk{} }
func (m *Walk) String() string { return proto.CompactTextString(m) }
func (*Walk) ProtoMessage()    {}
func (*Walk) Descriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{4}
}

func (m *Walk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Walk.Unmarshal(m, b)
}
func (m *Walk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Walk.Marshal(b, m, deterministic)
}
func (m *Walk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Walk.Merge(m, src)
}
func (m *Walk) XXX_Size() int {
	return xxx_messageInfo_Walk.Size(m)
}
func (m *Walk) XXX_DiscardUnknown() {
	xxx_messageInfo_Walk.DiscardUnknown(m)
}

var xxx_messageInfo_Walk proto.InternalMessageInfo

func (m *Walk) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Walk) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Walk) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *Walk) GetFile() []*File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *Walk) GetNotification() []*Notification {
	if m != nil {
		return m.Notification
	}
	return nil
}

func (m *Walk) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Walk) GetStartWalk() *timestamp.Timestamp {
	if m != nil {
		return m.StartWalk
	}
	return nil
}

func (m *Walk) GetStopWalk() *timestamp.Timestamp {
	if m != nil {
		return m.StopWalk
	}
	return nil
}

type Notification struct {
	Severity Notification_Severity `protobuf:"varint,1,opt,name=severity,proto3,enum=fswalker.Notification_Severity" json:"severity,omitempty"`
	// path where the notification occurred.
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// human readable message.
	Message              string   `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Notification) Reset()         { *m = Notification{} }
func (m *Notification) String() string { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()    {}
func (*Notification) Descriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{5}
}

func (m *Notification) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Notification.Unmarshal(m, b)
}
func (m *Notification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Notification.Marshal(b, m, deterministic)
}
func (m *Notification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notification.Merge(m, src)
}
func (m *Notification) XXX_Size() int {
	return xxx_messageInfo_Notification.Size(m)
}
func (m *Notification) XXX_DiscardUnknown() {
	xxx_messageInfo_Notification.DiscardUnknown(m)
}

var xxx_messageInfo_Notification proto.InternalMessageInfo

func (m *Notification) GetSeverity() Notification_Severity {
	if m != nil {
		return m.Severity
	}
	return Notification_UNKNOWN
}

func (m *Notification) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Notification) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type FileInfo struct {
	// base name of the file
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// length in bytes for regular files; system-dependent for others
	Size int64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// file mode bits
	Mode uint32 `protobuf:"varint,3,opt,name=mode,proto3" json:"mode,omitempty"`
	// modification time
	Modified *timestamp.Timestamp `protobuf:"bytes,4,opt,name=modified,proto3" json:"modified,omitempty"`
	// abbreviation for Mode().IsDir()
	IsDir                bool     `protobuf:"varint,5,opt,name=is_dir,json=isDir,proto3" json:"is_dir,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{6}
}

func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileInfo.Unmarshal(m, b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileInfo.Marshal(b, m, deterministic)
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return xxx_messageInfo_FileInfo.Size(m)
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func (m *FileInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileInfo) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *FileInfo) GetMode() uint32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *FileInfo) GetModified() *timestamp.Timestamp {
	if m != nil {
		return m.Modified
	}
	return nil
}

func (m *FileInfo) GetIsDir() bool {
	if m != nil {
		return m.IsDir
	}
	return false
}

type FileStat struct {
	Dev                  uint64               `protobuf:"varint,1,opt,name=dev,proto3" json:"dev,omitempty"`
	Inode                uint64               `protobuf:"varint,2,opt,name=inode,proto3" json:"inode,omitempty"`
	Nlink                uint64               `protobuf:"varint,3,opt,name=nlink,proto3" json:"nlink,omitempty"`
	Mode                 uint32               `protobuf:"varint,4,opt,name=mode,proto3" json:"mode,omitempty"`
	Uid                  uint32               `protobuf:"varint,5,opt,name=uid,proto3" json:"uid,omitempty"`
	Gid                  uint32               `protobuf:"varint,6,opt,name=gid,proto3" json:"gid,omitempty"`
	Rdev                 uint64               `protobuf:"varint,7,opt,name=rdev,proto3" json:"rdev,omitempty"`
	Size                 int64                `protobuf:"varint,8,opt,name=size,proto3" json:"size,omitempty"`
	Blksize              int64                `protobuf:"varint,9,opt,name=blksize,proto3" json:"blksize,omitempty"`
	Blocks               int64                `protobuf:"varint,10,opt,name=blocks,proto3" json:"blocks,omitempty"`
	Atime                *timestamp.Timestamp `protobuf:"bytes,11,opt,name=atime,proto3" json:"atime,omitempty"`
	Mtime                *timestamp.Timestamp `protobuf:"bytes,12,opt,name=mtime,proto3" json:"mtime,omitempty"`
	Ctime                *timestamp.Timestamp `protobuf:"bytes,13,opt,name=ctime,proto3" json:"ctime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *FileStat) Reset()         { *m = FileStat{} }
func (m *FileStat) String() string { return proto.CompactTextString(m) }
func (*FileStat) ProtoMessage()    {}
func (*FileStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{7}
}

func (m *FileStat) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileStat.Unmarshal(m, b)
}
func (m *FileStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileStat.Marshal(b, m, deterministic)
}
func (m *FileStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStat.Merge(m, src)
}
func (m *FileStat) XXX_Size() int {
	return xxx_messageInfo_FileStat.Size(m)
}
func (m *FileStat) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStat.DiscardUnknown(m)
}

var xxx_messageInfo_FileStat proto.InternalMessageInfo

func (m *FileStat) GetDev() uint64 {
	if m != nil {
		return m.Dev
	}
	return 0
}

func (m *FileStat) GetInode() uint64 {
	if m != nil {
		return m.Inode
	}
	return 0
}

func (m *FileStat) GetNlink() uint64 {
	if m != nil {
		return m.Nlink
	}
	return 0
}

func (m *FileStat) GetMode() uint32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *FileStat) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *FileStat) GetGid() uint32 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *FileStat) GetRdev() uint64 {
	if m != nil {
		return m.Rdev
	}
	return 0
}

func (m *FileStat) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *FileStat) GetBlksize() int64 {
	if m != nil {
		return m.Blksize
	}
	return 0
}

func (m *FileStat) GetBlocks() int64 {
	if m != nil {
		return m.Blocks
	}
	return 0
}

func (m *FileStat) GetAtime() *timestamp.Timestamp {
	if m != nil {
		return m.Atime
	}
	return nil
}

func (m *FileStat) GetMtime() *timestamp.Timestamp {
	if m != nil {
		return m.Mtime
	}
	return nil
}

func (m *FileStat) GetCtime() *timestamp.Timestamp {
	if m != nil {
		return m.Ctime
	}
	return nil
}

// Fingerprint is a unique identifier for a given File.
// It consists of a Method (e.g. SHA256) and a value.
type Fingerprint struct {
	Method               Fingerprint_Method `protobuf:"varint,1,opt,name=method,proto3,enum=fswalker.Fingerprint_Method" json:"method,omitempty"`
	Value                string             `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Fingerprint) Reset()         { *m = Fingerprint{} }
func (m *Fingerprint) String() string { return proto.CompactTextString(m) }
func (*Fingerprint) ProtoMessage()    {}
func (*Fingerprint) Descriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{8}
}

func (m *Fingerprint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Fingerprint.Unmarshal(m, b)
}
func (m *Fingerprint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Fingerprint.Marshal(b, m, deterministic)
}
func (m *Fingerprint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fingerprint.Merge(m, src)
}
func (m *Fingerprint) XXX_Size() int {
	return xxx_messageInfo_Fingerprint.Size(m)
}
func (m *Fingerprint) XXX_DiscardUnknown() {
	xxx_messageInfo_Fingerprint.DiscardUnknown(m)
}

var xxx_messageInfo_Fingerprint proto.InternalMessageInfo

func (m *Fingerprint) GetMethod() Fingerprint_Method {
	if m != nil {
		return m.Method
	}
	return Fingerprint_UNKNOWN
}

func (m *Fingerprint) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type File struct {
	// version is the version of the proto structure.
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// path is the full file path including the file name.
	Path string    `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Info *FileInfo `protobuf:"bytes,3,opt,name=info,proto3" json:"info,omitempty"`
	Stat *FileStat `protobuf:"bytes,4,opt,name=stat,proto3" json:"stat,omitempty"`
	// fingerprint is optionally set when requested for the specific file.
	Fingerprint          []*Fingerprint `protobuf:"bytes,5,rep,name=fingerprint,proto3" json:"fingerprint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_212418fc3e8c5a1a, []int{9}
}

func (m *File) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_File.Unmarshal(m, b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_File.Marshal(b, m, deterministic)
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return xxx_messageInfo_File.Size(m)
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (m *File) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *File) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *File) GetInfo() *FileInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *File) GetStat() *FileStat {
	if m != nil {
		return m.Stat
	}
	return nil
}

func (m *File) GetFingerprint() []*Fingerprint {
	if m != nil {
		return m.Fingerprint
	}
	return nil
}

func init() {
	proto.RegisterEnum("fswalker.Notification_Severity", Notification_Severity_name, Notification_Severity_value)
	proto.RegisterEnum("fswalker.Fingerprint_Method", Fingerprint_Method_name, Fingerprint_Method_value)
	proto.RegisterType((*Reviews)(nil), "fswalker.Reviews")
	proto.RegisterMapType((map[string]*Review)(nil), "fswalker.Reviews.ReviewEntry")
	proto.RegisterType((*Review)(nil), "fswalker.Review")
	proto.RegisterType((*ReportConfig)(nil), "fswalker.ReportConfig")
	proto.RegisterType((*Policy)(nil), "fswalker.Policy")
	proto.RegisterType((*Walk)(nil), "fswalker.Walk")
	proto.RegisterType((*Notification)(nil), "fswalker.Notification")
	proto.RegisterType((*FileInfo)(nil), "fswalker.FileInfo")
	proto.RegisterType((*FileStat)(nil), "fswalker.FileStat")
	proto.RegisterType((*Fingerprint)(nil), "fswalker.Fingerprint")
	proto.RegisterType((*File)(nil), "fswalker.File")
}

func init() { proto.RegisterFile("proto/fswalker.proto", fileDescriptor_212418fc3e8c5a1a) }

var fileDescriptor_212418fc3e8c5a1a = []byte{
	// 1001 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0x66, 0xd7, 0xeb, 0xf5, 0xfa, 0x38, 0x49, 0xdd, 0x21, 0x0d, 0x4b, 0x54, 0x88, 0x59, 0x89,
	0xca, 0x02, 0xc9, 0x41, 0xa1, 0x3f, 0xb4, 0x5c, 0x95, 0xa6, 0xa1, 0x56, 0x85, 0x53, 0x4d, 0x40,
	0x91, 0xb8, 0xb1, 0x36, 0xde, 0x59, 0x7b, 0xe4, 0xdd, 0x1d, 0x6b, 0x66, 0xec, 0x3a, 0x15, 0x37,
	0x3c, 0x00, 0x97, 0xbc, 0x09, 0x12, 0x57, 0xbc, 0x00, 0x4f, 0xc3, 0x23, 0xa0, 0x39, 0xb3, 0xeb,
	0x38, 0x56, 0xd4, 0xf4, 0x2a, 0xe7, 0x7c, 0xdf, 0x77, 0x7e, 0x72, 0xe6, 0xcc, 0xac, 0x61, 0x77,
	0x26, 0x85, 0x16, 0x87, 0xa9, 0x7a, 0x1b, 0x67, 0x53, 0x26, 0x7b, 0xe8, 0x92, 0xa0, 0xf2, 0xf7,
	0x0f, 0xc6, 0x42, 0x8c, 0x33, 0x76, 0x88, 0xf8, 0xc5, 0x3c, 0x3d, 0xd4, 0x3c, 0x67, 0x4a, 0xc7,
	0xf9, 0xcc, 0x4a, 0xa3, 0x3f, 0x1c, 0x68, 0x50, 0xb6, 0xe0, 0xec, 0xad, 0x22, 0x8f, 0xc0, 0x97,
	0x68, 0x86, 0x4e, 0xa7, 0xd6, 0x6d, 0x1d, 0x7d, 0xd6, 0x5b, 0xe5, 0x2d, 0x25, 0xe5, 0xdf, 0x97,
	0x85, 0x96, 0x97, 0xb4, 0x14, 0xef, 0xbf, 0x86, 0xd6, 0x1a, 0x4c, 0xda, 0x50, 0x9b, 0xb2, 0xcb,
	0xd0, 0xe9, 0x38, 0xdd, 0x26, 0x35, 0x26, 0x79, 0x00, 0xf5, 0x45, 0x9c, 0xcd, 0x59, 0xe8, 0x76,
	0x9c, 0x6e, 0xeb, 0xa8, 0xbd, 0x99, 0x96, 0x5a, 0xfa, 0x99, 0xfb, 0x9d, 0x13, 0xfd, 0xee, 0x80,
	0x6f, 0x51, 0xf2, 0x09, 0x34, 0x8c, 0x6c, 0xc8, 0x93, 0x32, 0x99, 0x6f, 0xdc, 0x7e, 0x42, 0xbe,
	0x84, 0x1d, 0x24, 0x24, 0x4b, 0x99, 0x64, 0xc5, 0xc8, 0x26, 0x6e, 0xd2, 0x6d, 0x83, 0xd2, 0x0a,
	0x24, 0x4f, 0xa0, 0x95, 0xf2, 0x62, 0xcc, 0xe4, 0x4c, 0xf2, 0x42, 0x87, 0x35, 0x2c, 0x7e, 0xef,
	0xaa, 0xf8, 0xc9, 0x15, 0x49, 0xd7, 0x95, 0x51, 0x1f, 0xb6, 0x28, 0x9b, 0x09, 0xa9, 0x5f, 0x88,
	0x22, 0xe5, 0x63, 0x12, 0x42, 0x63, 0xc1, 0xa4, 0xe2, 0xa2, 0xc0, 0x46, 0xb6, 0x69, 0xe5, 0x92,
	0x03, 0x68, 0xb1, 0xe5, 0x28, 0x9b, 0x27, 0x6c, 0x38, 0x4b, 0x97, 0xa1, 0xdb, 0xa9, 0x75, 0x9b,
	0x14, 0x4a, 0xe8, 0x4d, 0xba, 0x8c, 0xfe, 0x76, 0xc1, 0x7f, 0x23, 0x32, 0x3e, 0xba, 0x7c, 0x4f,
	0x96, 0x10, 0x1a, 0xbc, 0xc0, 0x90, 0x32, 0x43, 0xe5, 0x6e, 0xe6, 0xaf, 0x6d, 0xe6, 0x27, 0x9f,
	0x42, 0x30, 0x89, 0xd5, 0x04, 0x59, 0xcf, 0xc6, 0x1a, 0xdf, 0x50, 0x5f, 0x03, 0xc9, 0xe3, 0xe5,
	0x10, 0xe9, 0x94, 0x67, 0x6c, 0xa8, 0xf8, 0x3b, 0x16, 0xd6, 0x3b, 0x4e, 0xb7, 0x46, 0xef, 0xe4,
	0xf1, 0xf2, 0x55, 0xac, 0x26, 0x27, 0x3c, 0x63, 0x67, 0xfc, 0x1d, 0x23, 0x5f, 0xc1, 0x5d, 0x1c,
	0xe9, 0x48, 0x0a, 0xa5, 0x86, 0x09, 0x5b, 0xf0, 0x11, 0x0b, 0x3f, 0xef, 0x38, 0xdd, 0x80, 0xde,
	0x31, 0xc4, 0x0b, 0x83, 0x1f, 0x23, 0x4c, 0x1e, 0xc2, 0x1e, 0x1f, 0x17, 0x42, 0xb2, 0x21, 0x97,
	0x92, 0x8d, 0xe7, 0x59, 0x2c, 0xb1, 0x80, 0x0a, 0x0f, 0x30, 0x60, 0xd7, 0xb2, 0xfd, 0x8a, 0x34,
	0x45, 0x14, 0xe9, 0xc1, 0xc7, 0xa6, 0x9d, 0x84, 0x4b, 0x36, 0xd2, 0x42, 0x5e, 0x0e, 0x13, 0x36,
	0xd3, 0x93, 0xb0, 0x83, 0xa3, 0xb8, 0x9b, 0xc7, 0xcb, 0xe3, 0x8a, 0x39, 0x36, 0x44, 0xf4, 0xaf,
	0x0b, 0xde, 0x79, 0x9c, 0x4d, 0xc9, 0x0e, 0xb8, 0xab, 0x0d, 0x70, 0x79, 0xb2, 0x3e, 0x47, 0xf7,
	0xfa, 0x1c, 0xbb, 0xe0, 0xcf, 0x70, 0xd6, 0xe5, 0x59, 0xaf, 0x2d, 0x9a, 0x3d, 0x03, 0x5a, 0xf2,
	0x24, 0x02, 0xcf, 0x74, 0x8c, 0x23, 0x6b, 0x1d, 0xed, 0xac, 0xef, 0x44, 0xc6, 0x28, 0x72, 0xe4,
	0x19, 0x6c, 0x15, 0x42, 0xf3, 0x94, 0x8f, 0x62, 0x6d, 0x8a, 0xd5, 0x51, 0xbb, 0x77, 0xa5, 0x1d,
	0xac, 0xb1, 0xf4, 0x9a, 0x96, 0xec, 0x43, 0x30, 0x11, 0x4a, 0x17, 0x71, 0xce, 0x42, 0xc0, 0xce,
	0x57, 0x3e, 0x79, 0x0a, 0xa0, 0x74, 0x2c, 0xf5, 0xd0, 0xa4, 0x09, 0x5b, 0xd8, 0xe9, 0x7e, 0xcf,
	0xde, 0xd3, 0x5e, 0x75, 0x4f, 0x7b, 0x3f, 0x57, 0xf7, 0x94, 0x36, 0x51, 0x8d, 0xa3, 0x78, 0x02,
	0x4d, 0xa5, 0xc5, 0xcc, 0x46, 0x6e, 0xdd, 0x1a, 0x19, 0x18, 0xb1, 0x09, 0x8c, 0xfe, 0x72, 0x60,
	0x6b, 0xbd, 0x5d, 0xf2, 0x3d, 0x04, 0x8a, 0x2d, 0x98, 0xe4, 0xda, 0xde, 0xd4, 0x9d, 0xa3, 0x83,
	0x9b, 0xff, 0xb1, 0xde, 0x59, 0x29, 0xa3, 0xab, 0x00, 0x42, 0xc0, 0x9b, 0xc5, 0x7a, 0x52, 0xde,
	0x3a, 0xb4, 0xcd, 0xa9, 0xe4, 0x4c, 0xa9, 0x78, 0xcc, 0x70, 0xf8, 0x4d, 0x5a, 0xb9, 0xd1, 0x53,
	0x08, 0xaa, 0x1c, 0xa4, 0x05, 0x8d, 0x5f, 0x06, 0xaf, 0x07, 0xa7, 0xe7, 0x83, 0xf6, 0x47, 0x24,
	0x00, 0xaf, 0x3f, 0x38, 0x39, 0x6d, 0x3b, 0x06, 0x3e, 0x7f, 0x4e, 0x07, 0xfd, 0xc1, 0x8f, 0x6d,
	0x97, 0x34, 0xa1, 0xfe, 0x92, 0xd2, 0x53, 0xda, 0xae, 0x45, 0x7f, 0x3a, 0x10, 0x98, 0x13, 0xe9,
	0x17, 0xa9, 0x30, 0x55, 0x71, 0x9e, 0x76, 0x13, 0xd0, 0x36, 0x18, 0x6e, 0xb5, 0x8b, 0x5b, 0x8d,
	0xb6, 0xc1, 0x72, 0x91, 0xd8, 0x36, 0xb6, 0x29, 0xda, 0xe4, 0x31, 0x04, 0xb9, 0x48, 0x78, 0xca,
	0x59, 0x12, 0x7a, 0xb7, 0xcf, 0xad, 0xd2, 0x92, 0x7b, 0xe0, 0x73, 0x65, 0x76, 0x16, 0xef, 0x4d,
	0x40, 0xeb, 0x5c, 0x1d, 0x73, 0x19, 0xfd, 0xe7, 0xda, 0xbe, 0xce, 0x74, 0xac, 0xcd, 0x7b, 0x97,
	0xb0, 0x05, 0xb6, 0xe5, 0x51, 0x63, 0x92, 0x5d, 0xa8, 0xf3, 0x42, 0x24, 0xb6, 0x2d, 0x8f, 0x5a,
	0xc7, 0xa0, 0x45, 0xc6, 0x8b, 0x29, 0x36, 0xe6, 0x51, 0xeb, 0xac, 0xba, 0xf5, 0xd6, 0xba, 0x6d,
	0x43, 0x6d, 0xce, 0x13, 0x2c, 0xb9, 0x4d, 0x8d, 0x69, 0x90, 0x31, 0x4f, 0x42, 0xdf, 0x22, 0x63,
	0x9e, 0x98, 0x38, 0x69, 0xca, 0x36, 0x30, 0x19, 0xda, 0xab, 0x69, 0x04, 0x6b, 0xd3, 0x08, 0xa1,
	0x71, 0x91, 0x4d, 0x11, 0x6e, 0x22, 0x5c, 0xb9, 0x64, 0x0f, 0xfc, 0x8b, 0x4c, 0x8c, 0xa6, 0x0a,
	0x37, 0xb4, 0x46, 0x4b, 0x8f, 0x7c, 0x03, 0xf5, 0xd8, 0x7c, 0x25, 0x3e, 0x60, 0x35, 0xad, 0xd0,
	0x44, 0xe4, 0x18, 0x71, 0xfb, 0x4a, 0x5a, 0xa1, 0x89, 0x18, 0x61, 0xc4, 0xf6, 0xed, 0x11, 0x28,
	0x8c, 0x7e, 0x83, 0xd6, 0xda, 0x7b, 0x4d, 0x1e, 0x82, 0x9f, 0x33, 0x3d, 0x11, 0x49, 0xb9, 0xbd,
	0xf7, 0x6f, 0x7c, 0xd6, 0x7b, 0x3f, 0xa1, 0x86, 0x96, 0x5a, 0x73, 0x04, 0x57, 0x1f, 0xa2, 0x66,
	0xf9, 0xd9, 0x89, 0xbe, 0x00, 0xdf, 0xea, 0xae, 0xaf, 0x27, 0x80, 0x7f, 0xf6, 0xea, 0xf9, 0xd1,
	0xa3, 0xc7, 0x6d, 0x27, 0xfa, 0xc7, 0x01, 0xcf, 0x1c, 0xf8, 0x7b, 0x1e, 0xf1, 0x9b, 0x2e, 0xc5,
	0x03, 0xf0, 0x78, 0x91, 0x8a, 0xf2, 0x39, 0x22, 0xd7, 0x9f, 0x19, 0xb3, 0xd4, 0x14, 0x79, 0xa3,
	0x53, 0x3a, 0xd6, 0xe5, 0x6a, 0x6e, 0xe8, 0xcc, 0x92, 0x51, 0xe4, 0x37, 0xbf, 0x68, 0xf6, 0x45,
	0xfa, 0x80, 0x2f, 0xda, 0x0f, 0xf7, 0x7f, 0xdd, 0x1f, 0x73, 0x3d, 0x99, 0x5f, 0xf4, 0x46, 0x22,
	0x3f, 0x2c, 0x7f, 0x13, 0x54, 0x61, 0x17, 0x3e, 0x8e, 0xfd, 0xdb, 0xff, 0x03, 0x00, 0x00, 0xff,
	0xff, 0x7a, 0xf6, 0x6c, 0x62, 0x4d, 0x08, 0x00, 0x00,
}
